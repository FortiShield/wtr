#!/usr/bin/env bash
# branchops - Git worktree runner
# Portable, cross-platform git worktree management

set -e

# Version
BRANCHOPS_VERSION="2.1.0"

# Find the script directory (resolve symlinks; allow env override)
resolve_script_dir() {
  local src="${BASH_SOURCE[0]}"
  while [ -h "$src" ]; do
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ $src != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")/.." && pwd
}
: "${BRANCHOPS_DIR:=$(resolve_script_dir)}"

# Source library files
. "$BRANCHOPS_DIR/lib/log.sh"
. "$BRANCHOPS_DIR/lib/errors.sh"
. "$BRANCHOPS_DIR/lib/ui.sh"
. "$BRANCHOPS_DIR/lib/config.sh"
. "$BRANCHOPS_DIR/lib/platform.sh"
. "$BRANCHOPS_DIR/lib/core.sh"
. "$BRANCHOPS_DIR/lib/copy.sh"
. "$BRANCHOPS_DIR/lib/hooks.sh"

# Generic adapter functions (used when no explicit adapter file exists)
# These will be overridden if an adapter file is sourced
# Globals set by load_editor_adapter: BRANCHOPS_EDITOR_CMD, BRANCHOPS_EDITOR_CMD_NAME
editor_can_open() {
  command -v "$BRANCHOPS_EDITOR_CMD_NAME" >/dev/null 2>&1
}

editor_open() {
  local path="$1"
  local workspace="${2:-}"
  local target="$path"

  # Use workspace file if provided and exists
  if [ -n "$workspace" ] && [ -f "$workspace" ]; then
    target="$workspace"
  fi

  # $BRANCHOPS_EDITOR_CMD may contain arguments (e.g., "code --wait")
  # Using eval here is necessary to handle multi-word commands properly
  eval "$BRANCHOPS_EDITOR_CMD \"\$target\""
}

# Globals set by load_ai_adapter: BRANCHOPS_AI_CMD, BRANCHOPS_AI_CMD_NAME
ai_can_start() {
  command -v "$BRANCHOPS_AI_CMD_NAME" >/dev/null 2>&1
}

ai_start() {
  local path="$1"
  shift
  # $BRANCHOPS_AI_CMD may contain arguments (e.g., "bunx @github/copilot@latest")
  # Using eval here is necessary to handle multi-word commands properly
  (cd "$path" && eval "$BRANCHOPS_AI_CMD \"\$@\"")
}

# Main dispatcher
main() {
  local cmd="${1:-help}"
  shift 2>/dev/null || true

  case "$cmd" in
    create|new)
      cmd_create "$@"
      ;;
    rm)
      cmd_remove "$@"
      ;;
    go)
      cmd_go "$@"
      ;;
    run)
      cmd_run "$@"
      ;;
    editor)
      cmd_editor "$@"
      ;;
    ai)
      cmd_ai "$@"
      ;;
    copy)
      cmd_copy "$@"
      ;;
    ls|list)
      cmd_list "$@"
      ;;
    dashboard|status)
      cmd_dashboard "$@"
      ;;
    ui)
      cmd_ui "$@"
      ;;
    hooks)
      cmd_hooks "$@"
      ;;
    sync)
      cmd_sync "$@"
      ;;
    exec)
      cmd_exec "$@"
      ;;
    backup)
      cmd_backup "$@"
      ;;
    restore)
      cmd_restore "$@"
      ;;
    clean)
      cmd_clean "$@"
      ;;
    doctor)
      cmd_doctor "$@"
      ;;
    adapter|adapters)
      cmd_adapter "$@"
      ;;
    config)
      cmd_config "$@"
      ;;
    version|--version|-v)
      echo "git branchops version $BRANCHOPS_VERSION"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      log_error "Unknown command: $cmd"
      echo "Use 'git branchops help' for available commands"
      exit 1
      ;;
  esac
}

# Create command
cmd_create() {
  local branch_name=""
  local from_ref=""
  local from_current=0
  local track_mode="auto"
  local skip_copy=0
  local skip_fetch=0
  local yes_mode=0
  local force=0
  local custom_name=""
  local open_editor=0
  local start_ai=0
  local preset=""

  # Parse flags and arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --preset)
        preset="$2"
        shift 2
        ;;
      --from)
        from_ref="$2"
        shift 2
        ;;
      --from-current)
        from_current=1
        shift
        ;;
      --track)
        track_mode="$2"
        shift 2
        ;;
      --no-copy)
        skip_copy=1
        shift
        ;;
      --no-fetch)
        skip_fetch=1
        shift
        ;;
      --yes)
        yes_mode=1
        shift
        ;;
      --force)
        force=1
        shift
        ;;
      --name)
        custom_name="$2"
        shift 2
        ;;
      --editor|-e)
        open_editor=1
        shift
        ;;
      --ai|-a)
        start_ai=1
        shift
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        # Positional argument: treat as branch name
        if [ -z "$branch_name" ]; then
          branch_name="$1"
        fi
        shift
        ;;
    esac
  done

  # Validate flag combinations
  if [ "$force" -eq 1 ] && [ -z "$custom_name" ]; then
    log_error "--force requires --name to distinguish worktrees"
    if [ -n "$branch_name" ]; then
      echo "Example: git branchops new $branch_name --force --name backend" >&2
    else
      echo "Example: git branchops new feature-auth --force --name backend" >&2
    fi
    exit 1
  fi

  # Load preset if specified
  if [ -n "$preset" ]; then
    log_info "Applying preset: $preset"
    [ -z "$from_ref" ] && from_ref=$(cfg_get "branchops.preset.$preset.from")
    
    local p_from_current p_skip_copy p_skip_fetch p_track
    p_from_current=$(cfg_get "branchops.preset.$preset.fromCurrent")
    p_skip_copy=$(cfg_get "branchops.preset.$preset.skipCopy")
    p_skip_fetch=$(cfg_get "branchops.preset.$preset.skipFetch")
    p_track=$(cfg_get "branchops.preset.$preset.track")
    
    [ -n "$p_from_current" ] && [ "$from_current" -eq 0 ] && from_current="$p_from_current"
    [ -n "$p_skip_copy" ] && [ "$skip_copy" -eq 0 ] && skip_copy="$p_skip_copy"
    [ -n "$p_skip_fetch" ] && [ "$skip_fetch" -eq 0 ] && skip_fetch="$p_skip_fetch"
    [ -n "$p_track" ] && [ "$track_mode" = "auto" ] && track_mode="$p_track"
  fi

  # Get repo info
  local repo_root
  repo_root=$(discover_repo_root) || exit 1

  local base_dir prefix
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  # Get branch name if not provided
  if [ -z "$branch_name" ]; then
    if [ "$yes_mode" -eq 1 ]; then
      log_error "Branch name required in non-interactive mode"
      exit 1
    fi
    branch_name=$(prompt_input "Enter branch name:")
    if [ -z "$branch_name" ]; then
      log_error "Branch name required"
      exit 1
    fi
  fi

  # Determine from_ref with precedence: --from > --from-current > default
  if [ -z "$from_ref" ]; then
    if [ "$from_current" -eq 1 ]; then
      # Get current branch (try modern git first, then fallback)
      from_ref=$(git branch --show-current 2>/dev/null)
      if [ -z "$from_ref" ]; then
        from_ref=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
      fi

      # Handle detached HEAD state
      if [ -z "$from_ref" ] || [ "$from_ref" = "HEAD" ]; then
        log_warn "Currently in detached HEAD state - falling back to default branch"
        from_ref=$(resolve_default_branch "$repo_root")
      else
        log_info "Creating from current branch: $from_ref"
      fi
    else
      from_ref=$(resolve_default_branch "$repo_root")
    fi
  fi

  # Construct folder name for display
  local folder_name
  if [ -n "$custom_name" ]; then
    folder_name="$(sanitize_branch_name "$branch_name")-${custom_name}"
  else
    folder_name=$(sanitize_branch_name "$branch_name")
  fi

  log_step "Creating worktree: $folder_name"
  echo "Location: $base_dir/${prefix}${folder_name}"
  echo "Branch: $branch_name"

  # Run pre-create hooks (in main repo)
  if ! run_hooks preCreate \
    REPO_ROOT="$repo_root" \
    BRANCH="$branch_name" \
    FROM_REF="$from_ref"; then
    if [ "$force" -eq 0 ]; then
      log_error "Pre-create hook failed. Use --force to skip (not implemented for create yet) or fix the hook."
      exit 1
    fi
  fi

  # Create the worktree
  if ! worktree_path=$(create_worktree "$base_dir" "$prefix" "$branch_name" "$from_ref" "$track_mode" "$skip_fetch" "$force" "$custom_name"); then
    exit 1
  fi

  # Copy files based on patterns
  if [ "$skip_copy" -eq 0 ]; then
    local includes excludes file_includes
    # Pass .branchopsconfig keys as second argument for file-based config
    includes=$(cfg_get_all branchops.copy.include copy.include)
    excludes=$(cfg_get_all branchops.copy.exclude copy.exclude)

    # Read .worktreeinclude file if exists
    file_includes=$(parse_pattern_file "$repo_root/.worktreeinclude")

    # Merge patterns (newline-separated)
    if [ -n "$file_includes" ]; then
      if [ -n "$includes" ]; then
        includes="$includes"$'\n'"$file_includes"
      else
        includes="$file_includes"
      fi
    fi

    if [ -n "$includes" ]; then
      log_step "Copying files..."
      copy_patterns "$repo_root" "$worktree_path" "$includes" "$excludes"
    fi

    # Copy directories (typically git-ignored dirs like node_modules, .venv)
    local dir_includes dir_excludes
    # Pass .branchopsconfig keys as second argument for file-based config
    dir_includes=$(cfg_get_all branchops.copy.includeDirs copy.includeDirs)
    dir_excludes=$(cfg_get_all branchops.copy.excludeDirs copy.excludeDirs)

    if [ -n "$dir_includes" ]; then
      log_step "Copying directories..."
      copy_directories "$repo_root" "$worktree_path" "$dir_includes" "$dir_excludes"
    fi
  fi

  # Run post-create hooks
  run_hooks_in postCreate "$worktree_path" \
    REPO_ROOT="$repo_root" \
    WORKTREE_PATH="$worktree_path" \
    BRANCH="$branch_name"

  echo ""
  log_info "Worktree created: $worktree_path"

  # Auto-launch editor if requested
  if [ "$open_editor" -eq 1 ]; then
    local editor
    editor=$(cfg_default branchops.editor.default BRANCHOPS_EDITOR_DEFAULT "none" defaults.editor)
    if [ "$editor" != "none" ]; then
      load_editor_adapter "$editor"
      local workspace_file
      workspace_file=$(resolve_workspace_file "$worktree_path")
      log_step "Opening in $editor..."
      editor_open "$worktree_path" "$workspace_file"
    else
      open_in_gui "$worktree_path"
      log_info "Opened in file browser (no editor configured)"
    fi
  fi

  # Auto-launch AI tool if requested
  if [ "$start_ai" -eq 1 ]; then
    local ai_tool
    ai_tool=$(cfg_default branchops.ai.default BRANCHOPS_AI_DEFAULT "none" defaults.ai)
    if [ "$ai_tool" = "none" ]; then
      log_warn "No AI tool configured. Set with: git branchops config set branchops.ai.default claude"
    else
      load_ai_adapter "$ai_tool"
      log_step "Starting $ai_tool..."
      ai_start "$worktree_path"
    fi
  fi

  # Show next steps only if no auto-launch flags were used
  if [ "$open_editor" -eq 0 ] && [ "$start_ai" -eq 0 ]; then
    echo ""
    echo "Next steps:"
    echo "  git branchops editor $branch_name  # Open in editor"
    echo "  git branchops ai $branch_name      # Start AI tool"
    echo "  cd \"\$(git branchops go $branch_name)\"  # Navigate to worktree"
  fi
}

# Remove command
cmd_remove() {
  local delete_branch=0
  local yes_mode=0
  local force=0
  local identifiers=""

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --delete-branch)
        delete_branch=1
        shift
        ;;
      --yes)
        yes_mode=1
        shift
        ;;
      --force)
        force=1
        shift
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        identifiers="$identifiers $1"
        shift
        ;;
    esac
  done

  if [ -z "$identifiers" ]; then
    local selected
    selected=$(prompt_select_worktree "Select worktree to remove:") || exit 0
    identifiers="$selected"
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  for identifier in $identifiers; do
    # Resolve target branch
    local target is_main worktree_path branch_name
    target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || continue
    is_main=$(echo "$target" | cut -f1)
    worktree_path=$(echo "$target" | cut -f2)
    branch_name=$(echo "$target" | cut -f3)

    # Cannot remove main repository
    if [ "$is_main" = "1" ]; then
      log_error "Cannot remove main repository"
      continue
    fi

    log_step "Removing worktree: $(basename "$worktree_path")"

    # Run pre-remove hooks (abort on failure unless --force)
    if ! run_hooks_in preRemove "$worktree_path" \
      REPO_ROOT="$repo_root" \
      WORKTREE_PATH="$worktree_path" \
      BRANCH="$branch_name"; then
      if [ "$force" -eq 0 ]; then
        log_error "Pre-remove hook failed for $branch_name. Use --force to skip hooks."
        continue
      else
        log_warn "Pre-remove hook failed, continuing due to --force"
      fi
    fi

    # Remove the worktree
    if ! remove_worktree "$worktree_path" "$force"; then
      continue
    fi

    # Handle branch deletion
    if [ -n "$branch_name" ]; then
      if [ "$delete_branch" -eq 1 ]; then
        if [ "$yes_mode" -eq 1 ] || prompt_yes_no "Also delete branch '$branch_name'?"; then
          if git branch -D "$branch_name" 2>/dev/null; then
            log_info "Branch deleted: $branch_name"
          else
            log_warn "Could not delete branch: $branch_name"
          fi
        fi
      fi
    fi

    # Run post-remove hooks
    run_hooks postRemove \
      REPO_ROOT="$repo_root" \
      WORKTREE_PATH="$worktree_path" \
      BRANCH="$branch_name"
  done
}

# Go command (navigate to worktree - prints path for shell integration)
cmd_go() {
  if [ $# -ne 1 ]; then
    log_error "Usage: git branchops go <id|branch>"
    exit 1
  fi

  local identifier="$1"
  if [ -z "$identifier" ]; then
    identifier=$(prompt_select_worktree "Select worktree to navigate to:") || exit 0
  fi
  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  # Resolve target branch
  local target is_main worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  is_main=$(echo "$target" | cut -f1)
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  # Human messages to stderr so stdout can be used in command substitution
  if [ "$is_main" = "1" ]; then
    echo "Main repo" >&2
  else
    echo "Worktree: $branch" >&2
  fi
  echo "Branch: $branch" >&2

  # Print path to stdout for shell integration: cd "$(branchops go my-feature)"
  printf "%s\n" "$worktree_path"
}

# Run command (execute command in worktree directory)
cmd_run() {
  local identifier=""
  local -a run_args=()

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        if [ -z "$identifier" ]; then
          identifier="$1"
          shift
        else
          run_args=("$@")  # Capture all remaining args as the command
          break
        fi
        ;;
    esac
  done

  # Validation
  if [ -z "$identifier" ]; then
    identifier=$(prompt_select_worktree "Select worktree to run command in:") || exit 0
  fi

  if [ ${#run_args[@]} -eq 0 ]; then
    log_error "Usage: git branchops run <id|branch> <command...>"
    log_error "No command specified"
    exit 1
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  # Resolve target branch
  local target is_main worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  is_main=$(echo "$target" | cut -f1)
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  # Human messages to stderr (like cmd_go)
  if [ "$is_main" = "1" ]; then
    log_step "Running in: main repo"
  else
    log_step "Running in: $branch"
  fi
  echo "Command: ${run_args[*]}" >&2
  echo "" >&2

  # Execute command in worktree directory (exit code propagates)
  (cd "$worktree_path" && "${run_args[@]}")
}

# Copy command (copy files between worktrees)
cmd_copy() {
  local source="1"  # Default: main repo
  local targets=""
  local patterns=""
  local all_mode=0
  local dry_run=0

  # Parse arguments (patterns come after -- separator, like git pathspec)
  while [ $# -gt 0 ]; do
    case "$1" in
      --from)
        source="$2"
        shift 2
        ;;
      -n|--dry-run)
        dry_run=1
        shift
        ;;
      -a|--all)
        all_mode=1
        shift
        ;;
      --)
        shift
        # Remaining args are patterns (like git pathspec)
        while [ $# -gt 0 ]; do
          if [ -n "$patterns" ]; then
            patterns="$patterns"$'\n'"$1"
          else
            patterns="$1"
          fi
          shift
        done
        break
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        targets="$targets $1"
        shift
        ;;
    esac
  done

  # Validation
  if [ "$all_mode" -eq 0 ] && [ -z "$targets" ]; then
    log_error "Usage: git branchops copy <target>... [-n] [-a] [--from <source>] [-- <pattern>...]"
    exit 1
  fi

  # Get repo context
  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  # Resolve source path
  local src_target src_path
  src_target=$(resolve_target "$source" "$repo_root" "$base_dir" "$prefix") || exit 1
  src_path=$(echo "$src_target" | cut -f2)

  # Get patterns (flag > config)
  if [ -z "$patterns" ]; then
    patterns=$(cfg_get_all branchops.copy.include copy.include)
    # Also check .worktreeinclude
    if [ -f "$repo_root/.worktreeinclude" ]; then
      local file_patterns
      file_patterns=$(parse_pattern_file "$repo_root/.worktreeinclude")
      if [ -n "$file_patterns" ]; then
        if [ -n "$patterns" ]; then
          patterns="$patterns"$'\n'"$file_patterns"
        else
          patterns="$file_patterns"
        fi
      fi
    fi
  fi

  if [ -z "$patterns" ]; then
    log_error "No patterns specified. Use '-- <pattern>...' or configure branchops.copy.include"
    exit 1
  fi

  local excludes
  excludes=$(cfg_get_all branchops.copy.exclude copy.exclude)

  # Build target list for --all mode
  if [ "$all_mode" -eq 1 ]; then
    targets=$(list_worktree_branches "$base_dir" "$prefix")
    if [ -z "$targets" ]; then
      log_error "No worktrees found"
      exit 1
    fi
  fi

  # Process each target
  local copied_any=0
  for target_id in $targets; do
    local dst_target dst_path dst_branch
    dst_target=$(resolve_target "$target_id" "$repo_root" "$base_dir" "$prefix") || continue
    dst_path=$(echo "$dst_target" | cut -f2)
    dst_branch=$(echo "$dst_target" | cut -f3)

    # Skip if source == destination
    [ "$src_path" = "$dst_path" ] && continue

    if [ "$dry_run" -eq 1 ]; then
      log_step "[dry-run] Would copy to: $dst_branch"
      copy_patterns "$src_path" "$dst_path" "$patterns" "$excludes" "true" "true"
    else
      log_step "Copying to: $dst_branch"
      copy_patterns "$src_path" "$dst_path" "$patterns" "$excludes" "true"
    fi
    copied_any=1
  done

  if [ "$copied_any" -eq 0 ]; then
    log_warn "No files copied (source and target may be the same)"
  fi
}

# Editor command
cmd_editor() {
  local identifier=""
  local editor=""

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --editor)
        editor="$2"
        shift 2
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        if [ -z "$identifier" ]; then
          identifier="$1"
        fi
        shift
        ;;
    esac
  done

  if [ -z "$identifier" ]; then
    identifier=$(prompt_select_worktree "Select worktree to open in editor:") || exit 0
  fi

  # Get editor from flag or config (with .branchopsconfig support)
  if [ -z "$editor" ]; then
    editor=$(cfg_default branchops.editor.default BRANCHOPS_EDITOR_DEFAULT "none" defaults.editor)
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  # Resolve target branch
  local target worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  if [ "$editor" = "none" ]; then
    # Just open in GUI file browser
    open_in_gui "$worktree_path"
    log_info "Opened in file browser"
  else
    # Load editor adapter and open
    load_editor_adapter "$editor"
    local workspace_file
    workspace_file=$(resolve_workspace_file "$worktree_path")
    log_step "Opening in $editor..."
    editor_open "$worktree_path" "$workspace_file"
  fi
}

# AI command
cmd_ai() {
  local identifier=""
  local ai_tool=""
  local -a ai_args=()

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --ai)
        ai_tool="$2"
        shift 2
        ;;
      --)
        shift
        ai_args=("$@")
        break
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        if [ -z "$identifier" ]; then
          identifier="$1"
        fi
        shift
        ;;
    esac
  done

  if [ -z "$identifier" ]; then
    identifier=$(prompt_select_worktree "Select worktree to start AI tool in:") || exit 0
  fi

  # Get AI tool from flag or config (with .branchopsconfig support)
  if [ -z "$ai_tool" ]; then
    ai_tool=$(cfg_default branchops.ai.default BRANCHOPS_AI_DEFAULT "none" defaults.ai)
  fi

  # Check if AI tool is configured
  if [ "$ai_tool" = "none" ]; then
    log_error "No AI tool configured"
    log_info "Set default: git branchops config set branchops.ai.default claude"
    exit 1
  fi

  # Load AI adapter
  load_ai_adapter "$ai_tool"

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  # Resolve target branch
  local target worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  log_step "Starting $ai_tool for: $branch"
  echo "Directory: $worktree_path"
  echo "Branch: $branch"

  ai_start "$worktree_path" "${ai_args[@]}"
}

# Dashboard command
cmd_dashboard() {
  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  log_step "Worktree Dashboard"
  echo ""

  local data=()
  # Header
  data+=("ID\tBRANCH\tSTATUS\tLAST COMMIT\tCHANGES")

  # Main repo
  local branch status last_commit changes
  branch=$(current_branch "$repo_root")
  status=$(worktree_status "$repo_root")
  [ "$status" = "clean" ] && status="${GREEN}clean${RESET}" || status="${RED}dirty${RESET}"
  last_commit=$(git -C "$repo_root" log -1 --format=%cr 2>/dev/null || echo "never")
  changes=$(git -C "$repo_root" status --porcelain | wc -l | tr -d ' ')
  data+=("1\t$branch\t$status\t$last_commit\t$changes files")

  # Worktrees
  if [ -d "$base_dir" ]; then
    while read -r dir; do
      local b s lc c f
      b=$(current_branch "$dir")
      s=$(worktree_status "$dir")
      [ "$s" = "clean" ] && s="${GREEN}clean${RESET}" || s="${RED}dirty${RESET}"
      lc=$(git -C "$dir" log -1 --format=%cr 2>/dev/null || echo "never")
      c=$(git -C "$dir" status --porcelain | wc -l | tr -d ' ')
      f=$(basename "$dir")
      local id="${f#$prefix}"
      data+=("$id\t$b\t$s\t$lc\t$c files")
    done < <(find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | sort)
  fi

  print_table "10,20,10,20,15" "${data[@]}"
  echo ""
}

# UI command (interactive dashboard)
cmd_ui() {
  while true; do
    clear
    cmd_dashboard
    
    local id
    id=$(prompt_select_worktree "Select worktree to operate on (or ESC to exit):") || break
    [ -z "$id" ] && break
    
    echo ""
    echo "Actions for $id:"
    echo "1) Open in Editor"
    echo "2) Start AI tool"
    echo "3) Navigate to (print path)"
    echo "4) Sync (rebase)"
    echo "5) Remove worktree"
    echo "6) Back"
    echo "q) Quit"
    
    local act
    act=$(prompt_input "Action:")
    case "$act" in
      1) cmd_editor "$id" ;;
      2) cmd_ai "$id" ;;
      3) cmd_go "$id" ; prompt_input "Press Enter to continue..." ;;
      4) cmd_sync "$id" ; prompt_input "Press Enter to continue..." ;;
      5) cmd_remove "$id" ; prompt_input "Press Enter to continue..." ;;
      6) continue ;;
      q) break ;;
    esac
  done
}

# Sync command
cmd_sync() {
  local strategy="rebase"
  local all_mode=0
  local targets=()
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --strategy) strategy="$2"; shift 2 ;;
      --merge) strategy="merge"; shift ;;
      --rebase) strategy="rebase"; shift ;;
      --reset) strategy="reset"; shift ;;
      -a|--all) all_mode=1; shift ;;
      -*) log_error "Unknown flag: $1"; exit 1 ;;
      *) targets+=("$1"); shift ;;
    esac
  done
  
  if [ "$all_mode" -eq 1 ]; then
    local repo_root base_dir prefix
    repo_root=$(discover_repo_root) || exit 1
    base_dir=$(resolve_base_dir "$repo_root")
    prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")
    targets=("1" $(list_worktree_branches "$base_dir" "$prefix"))
  elif [ ${#targets[@]} -eq 0 ]; then
    local selected
    selected=$(prompt_select_worktree "Select worktree to sync:") || exit 0
    targets=("$selected")
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  for id in "${targets[@]}"; do
    local target path branch
    target=$(resolve_target "$id" "$repo_root" "$base_dir" "$prefix") || continue
    path=$(echo "$target" | cut -f2)
    branch=$(echo "$target" | cut -f3)
    
    log_step "Syncing $branch ($strategy)..."
    
    run_hooks_in preSync "$path" \
      REPO_ROOT="$repo_root" \
      WORKTREE_PATH="$path" \
      BRANCH="$branch" || continue

    # Prepare command
    local update_cmd=()
    if [ "$strategy" = "reset" ]; then
      update_cmd=(git reset --hard "origin/$branch")
    else
      update_cmd=(git "$strategy" "origin/$branch")
    fi

    if (cd "$path" && git fetch origin && "${update_cmd[@]}"); then
      log_success "Synced $branch"
      run_hooks_in postSync "$path" \
        REPO_ROOT="$repo_root" \
        WORKTREE_PATH="$path" \
        BRANCH="$branch"
    else
      log_error "Failed to sync $branch. Possible conflicts."
    fi
  done
}

# Exec command
cmd_exec() {
  local all_mode=0
  local parallel=0
  local targets=()
  local -a cmd_args=()
  
  while [ $# -gt 0 ]; do
    case "$1" in
      -a|--all) all_mode=1; shift ;;
      -p|--parallel) parallel=1; shift ;;
      --) shift; cmd_args=("$@"); break ;;
      -*) log_error "Unknown flag: $1"; exit 1 ;;
      *) targets+=("$1"); shift ;;
    esac
  done

  if [ ${#cmd_args[@]} -eq 0 ]; then
    log_error "No command specified. Use '-- <command>'"
    exit 1
  fi

  if [ "$all_mode" -eq 1 ]; then
    local repo_root base_dir prefix
    repo_root=$(discover_repo_root) || exit 1
    base_dir=$(resolve_base_dir "$repo_root")
    prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")
    targets=("1" $(list_worktree_branches "$base_dir" "$prefix"))
  elif [ ${#targets[@]} -eq 0 ]; then
    local selected
    selected=$(prompt_select_worktree "Select worktree to run in:") || exit 0
    targets=("$selected")
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  local pids=()
  for id in "${targets[@]}"; do
    local target path branch
    target=$(resolve_target "$id" "$repo_root" "$base_dir" "$prefix") || continue
    path=$(echo "$target" | cut -f2)
    branch=$(echo "$target" | cut -f3)

    if [ "$parallel" -eq 1 ]; then
      (
        log_step "[$branch] Running: ${cmd_args[*]}"
        run_hooks_in preExec "$path" BRANCH="$branch" || exit 1
        (cd "$path" && "${cmd_args[@]}") 2>&1 | sed "s/^/[$branch] /"
        run_hooks_in postExec "$path" BRANCH="$branch"
      ) &
      pids+=($!)
    else
      log_step "[$branch] Running: ${cmd_args[*]}"
      run_hooks_in preExec "$path" BRANCH="$branch" || continue
      (cd "$path" && "${cmd_args[@]}")
      run_hooks_in postExec "$path" BRANCH="$branch"
    fi
  done

  if [ "$parallel" -eq 1 ]; then
    for pid in "${pids[@]}"; do
      wait "$pid"
    done
  fi
}

# Hooks command
cmd_hooks() {
  local sub="${1:-help}"
  shift 2>/dev/null || true
  
  case "$sub" in
    sync)
      local repo_root base_dir prefix
      repo_root=$(discover_repo_root) || exit 1
      base_dir=$(resolve_base_dir "$repo_root")
      prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")
      
      local hook_src="$repo_root/.branchops/git-hooks"
      if [ ! -d "$hook_src" ]; then
        log_error "No Git hooks found in $hook_src"
        exit 1
      fi
      
      log_step "Syncing Git hooks to all worktrees..."
      local targets=("1" $(list_worktree_branches "$base_dir" "$prefix"))
      for id in "${targets[@]}"; do
        local target path branch
        target=$(resolve_target "$id" "$repo_root" "$base_dir" "$prefix") || continue
        path=$(echo "$target" | cut -f2)
        branch=$(echo "$target" | cut -f3)
        
        log_info "Syncing to $branch..."
        mkdir -p "$path/.git/hooks"
        cp "$hook_src"/* "$path/.git/hooks/" 2>/dev/null || true
        chmod +x "$path/.git/hooks"/* 2>/dev/null || true
      done
      ;;
    *)
      echo "Usage: git branchops hooks sync"
      ;;
  esac
}

# Backup command
cmd_backup() {
  local identifier="$1"
  if [ -z "$identifier" ]; then
    identifier=$(prompt_select_worktree "Select worktree to backup:") || exit 0
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  local target path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_dir="$repo_root/.branchops/backups/$(sanitize_branch_name "$branch")/$timestamp"
  mkdir -p "$backup_dir"

  log_step "Backing up $branch to $backup_dir..."

  # Backup commits
  (cd "$path" && git bundle create "$backup_dir/commits.bundle" HEAD)
  
  # Backup dirty state
  if [ "$(worktree_status "$path")" = "dirty" ]; then
    log_info "Worktree is dirty, backing up uncommitted changes..."
    # Archive excluding .git and other worktrees if any
    tar -czf "$backup_dir/dirty.tar.gz" -C "$path" --exclude=".git" .
  fi

  log_success "Backup completed: $backup_dir"
}

# Restore command
cmd_restore() {
  local backup_path="$1"
  if [ -z "$backup_path" ]; then
    log_error "Usage: git branchops restore <backup_path>"
    exit 1
  fi

  if [ ! -d "$backup_path" ]; then
    log_error "Backup path not found: $backup_path"
    exit 1
  fi

  local branch
  branch=$(basename "$(dirname "$backup_path")")
  log_step "Restoring branch: $branch"

  # Create new worktree from bundle
  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  
  # Unbundle to a temp branch or directly?
  # Better to create worktree first, then pull from bundle.
  log_info "Creating worktree for restoration..."
  local new_path
  new_path=$(cmd_create "$branch-restored" --no-copy --yes) || exit 1
  
  log_info "Restoring commits from bundle..."
  (cd "$new_path" && git pull "$backup_path/commits.bundle" HEAD)

  if [ -f "$backup_path/dirty.tar.gz" ]; then
    log_info "Restoring dirty state..."
    tar -xzf "$backup_path/dirty.tar.gz" -C "$new_path"
  fi

  log_success "Restoration completed to $new_path"
}

# List command
cmd_list() {
  local porcelain=0

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --porcelain)
        porcelain=1
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) 2>/dev/null || return 0
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  # Machine-readable output (porcelain)
  if [ "$porcelain" -eq 1 ]; then
    # Output: path<tab>branch<tab>status
    local branch status
    # Try --show-current (Git 2.22+), fallback to rev-parse for older Git
    branch=$(git -C "$repo_root" branch --show-current 2>/dev/null)
    [ -z "$branch" ] && branch=$(git -C "$repo_root" rev-parse --abbrev-ref HEAD 2>/dev/null)
    [ -z "$branch" ] || [ "$branch" = "HEAD" ] && branch="(detached)"
    status=$(worktree_status "$repo_root")
    printf "%s\t%s\t%s\n" "$repo_root" "$branch" "$status"

    if [ -d "$base_dir" ]; then
      # Find all worktree directories and output: path<tab>branch<tab>status
      find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | while IFS= read -r dir; do
        local branch status
        branch=$(current_branch "$dir")
        [ -z "$branch" ] && branch="(detached)"
        status=$(worktree_status "$dir")
        printf "%s\t%s\t%s\n" "$dir" "$branch" "$status"
      done | LC_ALL=C sort -k2,2
    fi
    return 0
  fi

  # Human-readable output - table format
  echo "Git Worktrees"
  echo ""
  printf "%-30s %s\n" "BRANCH" "PATH"
  printf "%-30s %s\n" "------" "----"

  # Always show repo root first
  local branch
  # Try --show-current (Git 2.22+), fallback to rev-parse for older Git
  branch=$(git -C "$repo_root" branch --show-current 2>/dev/null)
  [ -z "$branch" ] && branch=$(git -C "$repo_root" rev-parse --abbrev-ref HEAD 2>/dev/null)
  [ -z "$branch" ] || [ "$branch" = "HEAD" ] && branch="(detached)"
  printf "%-30s %s\n" "$branch [main repo]" "$repo_root"

  # Show worktrees sorted by branch name
  if [ -d "$base_dir" ]; then
    find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | while IFS= read -r dir; do
      local branch
      branch=$(current_branch "$dir")
      [ -z "$branch" ] && branch="(detached)"
      printf "%-30s %s\n" "$branch" "$dir"
    done | LC_ALL=C sort -k1,1
  fi

  echo ""
  echo ""
  echo "Tip: Use 'git branchops list --porcelain' for machine-readable output"
}

# Clean command (remove prunable worktrees)
cmd_clean() {
  local merged_mode=0
  local yes_mode=0
  local dry_run=0

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --merged)
        merged_mode=1
        shift
        ;;
      --yes|-y)
        yes_mode=1
        shift
        ;;
      --dry-run|-n)
        dry_run=1
        shift
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        shift
        ;;
    esac
  done

  log_step "Cleaning up stale worktrees..."

  # Run git worktree prune
  if git worktree prune 2>/dev/null; then
    log_info "Pruned stale worktree administrative files"
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

  if [ ! -d "$base_dir" ]; then
    log_info "No worktrees directory to clean"
    return 0
  fi

  # Find and remove empty directories
  local cleaned=0
  local empty_dirs
  empty_dirs=$(find "$base_dir" -maxdepth 1 -type d -empty 2>/dev/null | grep -v "^${base_dir}$" || true)

  if [ -n "$empty_dirs" ]; then
    while IFS= read -r dir; do
      if [ -n "$dir" ]; then
        if rmdir "$dir" 2>/dev/null; then
          cleaned=$((cleaned + 1))
          log_info "Removed empty directory: $(basename "$dir")"
        fi
      fi
    done <<EOF
$empty_dirs
EOF
  fi

  if [ "$cleaned" -gt 0 ]; then
    log_info "Cleanup complete ($cleaned director$([ "$cleaned" -eq 1 ] && echo 'y' || echo 'ies') removed)"
  else
    log_info "Cleanup complete (no empty directories found)"
  fi

  # --merged mode: remove worktrees with merged PRs (handles squash merges)
  if [ "$merged_mode" -eq 1 ]; then
    log_step "Checking for worktrees with merged PRs..."

    # Ensure gh CLI is available
    if ! command -v gh >/dev/null 2>&1; then
      log_error "GitHub CLI (gh) not found. Install from: https://cli.github.com/"
      exit 1
    fi

    # Ensure gh is authenticated and this is a GitHub repository
    if ! gh repo view >/dev/null 2>&1; then
      log_error "Not authenticated with GitHub or not a GitHub repository"
      log_info "Run: gh auth login"
      exit 1
    fi

    # Fetch latest from origin
    log_step "Fetching from origin..."
    git fetch origin --prune 2>/dev/null || log_warn "Could not fetch from origin"

    local removed=0
    local skipped=0

    # Get main repo branch to exclude it
    local main_branch
    main_branch=$(current_branch "$repo_root")

    # Iterate through worktree directories
    for dir in "$base_dir/${prefix}"*; do
      [ -d "$dir" ] || continue

      local branch
      branch=$(current_branch "$dir")

      if [ -z "$branch" ] || [ "$branch" = "(detached)" ]; then
        log_warn "Skipping $dir (detached HEAD)"
        skipped=$((skipped + 1))
        continue
      fi

      # Skip if same as main repo branch
      if [ "$branch" = "$main_branch" ]; then
        continue
      fi

      # Check if worktree has uncommitted changes
      if ! git -C "$dir" diff --quiet 2>/dev/null || \
         ! git -C "$dir" diff --cached --quiet 2>/dev/null; then
        log_warn "Skipping $branch (has uncommitted changes)"
        skipped=$((skipped + 1))
        continue
      fi

      # Check for untracked files
      if [ -n "$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null)" ]; then
        log_warn "Skipping $branch (has untracked files)"
        skipped=$((skipped + 1))
        continue
      fi

      # Check if branch has a merged PR on GitHub
      local pr_state
      pr_state=$(gh pr list --head "$branch" --state merged --json state --jq '.[0].state' 2>/dev/null || true)

      if [ "$pr_state" = "MERGED" ]; then
        if [ "$dry_run" -eq 1 ]; then
          log_info "[dry-run] Would remove: $branch ($dir)"
          removed=$((removed + 1))
        elif [ "$yes_mode" -eq 1 ] || prompt_yes_no "Remove worktree and delete branch '$branch'?"; then
          log_step "Removing worktree: $branch"
          local remove_output
          if remove_output=$(git worktree remove "$dir" 2>&1); then
            # Also delete the local branch
            git branch -d "$branch" 2>/dev/null || git branch -D "$branch" 2>/dev/null || true
            log_info "Removed: $branch"
            removed=$((removed + 1))
          else
            if [ -n "$remove_output" ]; then
              log_error "Failed to remove worktree: $remove_output"
            else
              log_error "Failed to remove worktree: $branch"
            fi
          fi
        else
          log_warn "Skipped: $branch (user declined)"
          skipped=$((skipped + 1))
        fi
      fi
      # Branches without merged PRs are silently skipped (this is the normal case)
    done

    echo ""
    if [ "$dry_run" -eq 1 ]; then
      log_info "Dry run complete. Would remove: $removed, Skipped: $skipped"
    else
      log_info "Merged cleanup complete. Removed: $removed, Skipped: $skipped"
    fi
  fi
}

# Doctor command (health check)
cmd_doctor() {
  echo "Running git branchops health check..."
  echo ""

  local issues=0

  # Check git
  if command -v git >/dev/null 2>&1; then
    local git_version
    git_version=$(git --version)
    echo "[OK] Git: $git_version"
  else
    echo "[x] Git: not found"
    issues=$((issues + 1))
  fi

  # Check repo
  local repo_root
  if repo_root=$(discover_repo_root 2>/dev/null); then
    echo "[OK] Repository: $repo_root"

    # Check worktree base dir
    local base_dir prefix
    base_dir=$(resolve_base_dir "$repo_root")
    prefix=$(cfg_default branchops.worktrees.prefix BRANCHOPS_WORKTREES_PREFIX "")

    if [ -d "$base_dir" ]; then
      local count
      count=$(find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | wc -l | tr -d ' ')
      echo "[OK] Worktrees directory: $base_dir ($count worktrees)"
    else
      echo "[i] Worktrees directory: $base_dir (not created yet)"
    fi
  else
    echo "[x] Not in a git repository"
    issues=$((issues + 1))
  fi

  # Check configured editor (with .branchopsconfig support)
  local editor
  editor=$(cfg_default branchops.editor.default BRANCHOPS_EDITOR_DEFAULT "none" defaults.editor)
  if [ "$editor" != "none" ]; then
    # Check if adapter exists
    local editor_adapter="$BRANCHOPS_DIR/adapters/editor/${editor}.sh"
    if [ -f "$editor_adapter" ]; then
      . "$editor_adapter"
      if editor_can_open 2>/dev/null; then
        echo "[OK] Editor: $editor (found)"
      else
        echo "[!] Editor: $editor (configured but not found in PATH)"
      fi
    else
      echo "[!] Editor: $editor (adapter not found)"
    fi
  else
    echo "[i] Editor: none configured"
  fi

  # Check configured AI tool (with .branchopsconfig support)
  local ai_tool
  ai_tool=$(cfg_default branchops.ai.default BRANCHOPS_AI_DEFAULT "none" defaults.ai)
  if [ "$ai_tool" != "none" ]; then
    # Check if adapter exists
    local adapter_file="$BRANCHOPS_DIR/adapters/ai/${ai_tool}.sh"
    if [ -f "$adapter_file" ]; then
      . "$adapter_file"
      if ai_can_start 2>/dev/null; then
        echo "[OK] AI tool: $ai_tool (found)"
      else
        echo "[!] AI tool: $ai_tool (configured but not found in PATH)"
      fi
    else
      echo "[!] AI tool: $ai_tool (adapter not found)"
    fi
  else
    echo "[i] AI tool: none configured"
  fi

  # Check OS
  local os
  os=$(detect_os)
  echo "[OK] Platform: $os"

  echo ""
  if [ "$issues" -eq 0 ]; then
    echo "Everything looks good!"
    return 0
  else
    echo "[!] Found $issues issue(s)"
    return 1
  fi
}

# Adapter command (list available adapters)
cmd_adapter() {
  echo "Available Adapters"
  echo ""

  # Editor adapters
  echo "Editor Adapters:"
  echo ""
  printf "%-15s %-15s %s\n" "NAME" "STATUS" "NOTES"
  printf "%-15s %-15s %s\n" "---------------" "---------------" "-----"

  for adapter_file in "$BRANCHOPS_DIR"/adapters/editor/*.sh; do
    if [ -f "$adapter_file" ]; then
      local adapter_name
      adapter_name=$(basename "$adapter_file" .sh)
      . "$adapter_file"

      if editor_can_open 2>/dev/null; then
        printf "%-15s %-15s %s\n" "$adapter_name" "[ready]" ""
      else
        printf "%-15s %-15s %s\n" "$adapter_name" "[missing]" "Not found in PATH"
      fi
    fi
  done

  echo ""
  echo ""
  echo "AI Tool Adapters:"
  echo ""
  printf "%-15s %-15s %s\n" "NAME" "STATUS" "NOTES"
  printf "%-15s %-15s %s\n" "---------------" "---------------" "-----"

  for adapter_file in "$BRANCHOPS_DIR"/adapters/ai/*.sh; do
    if [ -f "$adapter_file" ]; then
      local adapter_name
      adapter_name=$(basename "$adapter_file" .sh)
      . "$adapter_file"

      if ai_can_start 2>/dev/null; then
        printf "%-15s %-15s %s\n" "$adapter_name" "[ready]" ""
      else
        printf "%-15s %-15s %s\n" "$adapter_name" "[missing]" "Not found in PATH"
      fi
    fi
  done

  echo ""
  echo ""
  echo "Tip: Set defaults with:"
  echo "   git branchops config set branchops.editor.default <name>"
  echo "   git branchops config set branchops.ai.default <name>"
}

# Config command
cmd_config() {
  local scope="auto"
  local action="" key="" value=""
  local extra_args=""

  # Parse args flexibly: action, key, value, and --global/--local anywhere
  while [ $# -gt 0 ]; do
    case "$1" in
      --global|global)
        scope="global"
        shift
        ;;
      --local|local)
        scope="local"
        shift
        ;;
      --system|system)
        scope="system"
        shift
        ;;
      get|set|unset|add|list)
        action="$1"
        shift
        ;;
      *)
        if [ -z "$key" ]; then
          key="$1"
          shift
        elif [ -z "$value" ] && { [ "$action" = "set" ] || [ "$action" = "add" ]; }; then
          value="$1"
          shift
        else
          # Track extra tokens for validation (add space only if not first)
          extra_args="${extra_args:+$extra_args }$1"
          shift
        fi
        ;;
    esac
  done

  # Default action: list if no action and no key, otherwise get
  if [ -z "$action" ]; then
    if [ -z "$key" ]; then
      action="list"
    else
      action="get"
    fi
  fi

  # Resolve "auto" scope to "local" for set/add/unset operations (they need explicit scope)
  # This ensures log messages show the actual scope being used
  local resolved_scope="$scope"
  if [ "$scope" = "auto" ] && [ "$action" != "list" ] && [ "$action" != "get" ]; then
    resolved_scope="local"
  fi

  # Reject --system for write operations (requires root, not commonly useful)
  if [ "$scope" = "system" ]; then
    case "$action" in
      set|add|unset)
        log_error "--system is not supported for write operations (requires root privileges)"
        log_error "Use --local or --global instead"
        exit 1
        ;;
    esac
  fi

  case "$action" in
    get)
      if [ -z "$key" ]; then
        log_error "Usage: git branchops config get <key> [--local|--global|--system]"
        exit 1
      fi
      # Warn on unexpected extra arguments
      if [ -n "$extra_args" ]; then
        log_warn "get action: ignoring extra arguments: $extra_args"
      fi
      cfg_get_all "$key" "" "$scope"
      ;;
    set)
      if [ -z "$key" ] || [ -z "$value" ]; then
        log_error "Usage: git branchops config set <key> <value> [--local|--global]"
        exit 1
      fi
      # Warn on unexpected extra arguments
      if [ -n "$extra_args" ]; then
        log_warn "set action: ignoring extra arguments: $extra_args"
      fi
      cfg_set "$key" "$value" "$resolved_scope"
      log_info "Config set: $key = $value ($resolved_scope)"
      ;;
    add)
      if [ -z "$key" ] || [ -z "$value" ]; then
        log_error "Usage: git branchops config add <key> <value> [--local|--global]"
        exit 1
      fi
      # Warn on unexpected extra arguments
      if [ -n "$extra_args" ]; then
        log_warn "add action: ignoring extra arguments: $extra_args"
      fi
      cfg_add "$key" "$value" "$resolved_scope"
      log_info "Config added: $key = $value ($resolved_scope)"
      ;;
    unset)
      if [ -z "$key" ]; then
        log_error "Usage: git branchops config unset <key> [--local|--global]"
        exit 1
      fi
      # Warn on unexpected extra arguments (including value which unset doesn't use)
      if [ -n "$value" ] || [ -n "$extra_args" ]; then
        log_warn "unset action: ignoring extra arguments: ${value}${value:+ }${extra_args}"
      fi
      cfg_unset "$key" "$resolved_scope"
      log_info "Config unset: $key ($resolved_scope)"
      ;;
    list)
      # Warn on unexpected extra arguments
      if [ -n "$key" ] || [ -n "$extra_args" ]; then
        log_warn "list action doesn't accept additional arguments (ignoring: ${key}${key:+ }${extra_args})"
      fi
      # Use cfg_list for proper formatting and .branchopsconfig support
      cfg_list "$scope"
      ;;
    *)
      log_error "Unknown config action: $action"
      log_error "Usage: git branchops config [list] [--local|--global|--system]"
      log_error "       git branchops config {get|set|add|unset} <key> [value] [--local|--global]"
      exit 1
      ;;
  esac
}

# Resolve workspace file for VS Code/Cursor editors
# Returns the workspace file path if found, empty otherwise
resolve_workspace_file() {
  local worktree_path="$1"

  # Check config first (branchops.editor.workspace or editor.workspace in .branchopsconfig)
  local configured
  configured=$(cfg_default branchops.editor.workspace "" "" editor.workspace)

  # Opt-out: "none" disables workspace lookup entirely
  if [ "$configured" = "none" ]; then
    return 0
  fi

  if [ -n "$configured" ]; then
    local full_path="$worktree_path/$configured"
    if [ -f "$full_path" ]; then
      echo "$full_path"
    fi
    # Explicit config set - don't fall through to auto-detect
    return 0
  fi

  # Auto-detect: find first .code-workspace in worktree root
  local ws_file
  ws_file=$(find "$worktree_path" -maxdepth 1 -name "*.code-workspace" -type f 2>/dev/null | head -1)
  if [ -n "$ws_file" ]; then
    echo "$ws_file"
  fi
}

# Load editor adapter
load_editor_adapter() {
  local editor="$1"
  local adapter_file="$BRANCHOPS_DIR/adapters/editor/${editor}.sh"

  # Set defaults first (can be overridden by adapter)
  local cmd_name="${editor%% *}"
  BRANCHOPS_EDITOR_CMD="$editor"
  BRANCHOPS_EDITOR_CMD_NAME="$cmd_name"

  # Try loading explicit adapter first (allows special handling)
  if [ -f "$adapter_file" ]; then
    # If it's a script-style adapter (not just defining variables/functions), wrap it
    if grep -q "case \"\$1\" in" "$adapter_file"; then
      editor_open() {
        local path="$1"
        local workspace="${2:-}"
        local target="$path"
        [ -n "$workspace" ] && [ -f "$workspace" ] && target="$workspace"
        "$adapter_file" open "$target"
      }
    else
      . "$adapter_file"
    fi
    return 0
  fi

  if ! command -v "$cmd_name" >/dev/null 2>&1; then
    log_error "Editor '$editor' not found"
    log_info "Built-in adapters: cursor, vscode, zed, idea, pycharm, webstorm, vim, nvim, emacs, sublime, nano, atom"
    log_info "Or use any editor command available in your PATH (e.g., code-insiders, fleet)"
    exit 1
  fi
}

# Load AI adapter
load_ai_adapter() {
  local ai_tool="$1"
  local adapter_file="$BRANCHOPS_DIR/adapters/ai/${ai_tool}.sh"

  # Set defaults first
  local cmd_name="${ai_tool%% *}"
  BRANCHOPS_AI_CMD="$ai_tool"
  BRANCHOPS_AI_CMD_NAME="$cmd_name"

  # Try loading explicit adapter first (allows special handling)
  if [ -f "$adapter_file" ]; then
    if grep -q "case \"\$1\" in" "$adapter_file"; then
      ai_start() {
        local path="$1"
        shift
        (cd "$path" && "$adapter_file" open "$@")
      }
    else
      . "$adapter_file"
    fi
    return 0
  fi

  if ! command -v "$cmd_name" >/dev/null 2>&1; then
    log_error "AI tool '$ai_tool' not found"
    log_info "Built-in adapters: aider, claude, codex, continue, copilot, cursor, gemini, opencode"
    log_info "Or use any AI tool command available in your PATH (e.g., bunx, gpt)"
    exit 1
  fi
}

# Help command
cmd_help() {
  cat <<'EOF'
git branchops - Git worktree runner

PHILOSOPHY: Configuration over flags. Set defaults once, then use simple commands.



QUICK START:
  cd ~/your-repo                                   # Navigate to git repo first
  git branchops config set branchops.editor.default cursor     # One-time setup
  git branchops config set branchops.ai.default claude         # One-time setup
  git branchops new my-feature                           # Creates worktree in folder "my-feature"
  git branchops editor my-feature                        # Opens in cursor
  git branchops ai my-feature                            # Starts claude
  git branchops rm my-feature                            # Remove when done



KEY CONCEPTS:
   Worktree folders are named after the branch name
   Main repo is accessible via special ID '1' (e.g., git branchops go 1, git branchops editor 1)
   Commands accept branch names to identify worktrees
    Example: git branchops editor my-feature, git branchops go feature/user-auth



CORE COMMANDS (daily workflow):

  new <branch> [options]
         Create a new worktree (folder named after branch)
         --from <ref>: create from specific ref
         --from-current: create from current branch (for parallel variants)
         --track <mode>: tracking mode (auto|remote|local|none)
         --no-copy: skip file copying
         --no-fetch: skip git fetch
         --force: allow same branch in multiple worktrees (requires --name)
         --name <suffix>: custom folder name suffix (e.g., backend, frontend)
         --yes: non-interactive mode
         -e, --editor: open in editor after creation
         -a, --ai: start AI tool after creation

  editor <branch> [--editor <name>]
         Open worktree in editor (uses branchops.editor.default or --editor)
         Special: use '1' to open repo root

  ai <branch> [--ai <name>] [-- args...]
         Start AI coding tool in worktree (uses branchops.ai.default or --ai)
         Special: use '1' to open repo root

  go <branch>
         Navigate to worktree (prints path for: cd "$(git branchops go my-feature)")
         Special: use '1' for repo root

  run <branch> <command...>
         Execute command in worktree directory
         Special: use '1' to run in repo root

         Examples:
           git branchops run feature npm test
           git branchops run feature-auth git status
           git branchops run 1 npm run build

  list [--porcelain]
         List all worktrees
         Aliases: ls

  rm <branch> [<branch>...] [options]
         Remove worktree(s) by branch name
         --delete-branch: also delete the branch
         --force: force removal (dirty worktree)
         --yes: skip confirmation

  copy <target>... [options] [-- <pattern>...]
         Copy files from main repo to worktree(s)
         -n, --dry-run: preview without copying
         -a, --all: copy to all worktrees
         --from <source>: copy from different worktree (default: main repo)
         Patterns after -- override branchops.copy.include config

         Examples:
           git branchops copy my-feature                       # Uses configured patterns
           git branchops copy my-feature -- ".env*"            # Explicit pattern
           git branchops copy my-feature -- ".env*" "*.json"   # Multiple patterns
           git branchops copy -a -- ".env*"                    # Update all worktrees
           git branchops copy my-feature -n -- "**/.env*"      # Dry-run preview



SETUP & MAINTENANCE:

  config [list] [--local|--global|--system]
  config get <key> [--local|--global|--system]
  config {set|add|unset} <key> [value] [--local|--global]
         Manage configuration
         - list: show all branchops.* config values (default when no args)
         - get: read a config value (merged from all sources by default)
         - set: set a single value (replaces existing)
         - add: add a value (for multi-valued configs like hooks, copy patterns)
         - unset: remove a config value
         Without scope flag, list/get show merged config from all sources
         Use --local/--global to target a specific scope for write operations

  doctor
         Health check (verify git, editors, AI tools)

  adapter
         List available editor & AI tool adapters
         Note: Any command in your PATH can be used (e.g., code-insiders, bunx)

  clean [options]
         Remove stale/prunable worktrees and empty directories
         --merged: also remove worktrees with merged PRs (uses gh CLI)
         --yes, -y: skip confirmation prompts
         --dry-run, -n: show what would be removed without removing

  version
         Show version



WORKFLOW EXAMPLES:

  # One-time repo setup
  cd ~/GitHub/my-project
  git branchops config set branchops.editor.default cursor
  git branchops config set branchops.ai.default claude

  # Daily workflow
  git branchops new feature/user-auth               # Create worktree (folder: feature-user-auth)
  git branchops editor feature/user-auth            # Open in editor
  git branchops ai feature/user-auth                # Start AI tool

  # Run commands in worktree
  git branchops run feature/user-auth npm test      # Run tests
  git branchops run feature/user-auth npm run dev   # Start dev server

  # Navigate to worktree directory
  cd "$(git branchops go feature/user-auth)"

  # Override defaults with flags
  git branchops editor feature/user-auth --editor vscode
  git branchops ai feature/user-auth --ai aider

  # Chain commands together
  git branchops new hotfix && git branchops editor hotfix && git branchops ai hotfix

  # Create variant worktrees from current branch (for parallel work)
  git checkout feature/user-auth
  git branchops new variant-1 --from-current        # Creates variant-1 from feature/user-auth
  git branchops new variant-2 --from-current        # Creates variant-2 from feature/user-auth

  # When finished
  git branchops rm feature/user-auth --delete-branch

  # Check setup and available tools
  git branchops doctor
  git branchops adapter



CONFIGURATION OPTIONS:

  branchops.worktrees.dir        Worktrees base directory
  branchops.worktrees.prefix     Worktree folder prefix (default: "")
  branchops.defaultBranch        Default branch (default: auto)
  branchops.editor.default       Default editor
                           Options: cursor, vscode, vscode_remote, zed,
                           idea, pycharm, webstorm, nvim, vim, emacs,
                           sublime, atom, nano, none
  branchops.editor.workspace     Workspace file for VS Code/Cursor
                           (relative path, auto-detects, or "none")
  branchops.ai.default           Default AI tool
                           Options: aider, claude, codex, continue,
                           copilot, cursor, gemini, opencode, none
  branchops.copy.include         Files to copy (multi-valued)
  branchops.copy.exclude         Files to exclude (multi-valued)
  branchops.copy.includeDirs     Directories to copy (multi-valued)
                           Example: node_modules, .venv, vendor
                           WARNING: May include sensitive files!
                           Use branchops.copy.excludeDirs to exclude them.
  branchops.copy.excludeDirs     Directories to exclude (multi-valued)
                           Supports glob patterns (e.g., "node_modules/.cache", "*/.npm")
  branchops.hook.postCreate      Post-create hooks (multi-valued)
  branchops.hook.preRemove       Pre-remove hooks (multi-valued, abort on failure)
  branchops.hook.postRemove      Post-remove hooks (multi-valued)



MORE INFO: https://github.com/neopilot-ai/np-branchops
EOF
}

# Run main
main "$@"